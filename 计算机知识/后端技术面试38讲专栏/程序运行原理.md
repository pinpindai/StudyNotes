# 程序运行原理

## 程序是如何运行起来的

### 过程

- 编写

	- 源代码-文本格式

- 编译

	- 目标文件

- 链接

	- 静态库
	- 动态库
	- 可执行文件

- 运行

	- 从磁盘加载到内存
	- 操作系统调度
	- CPU执行

### 进程的内存空间

- 程序代码

	- 入口函数
	- 跳转指令

- 堆空间

	- 创建的对象
	- 程序申请的地址空间

- 栈空间

	- 栈帧

		- 调用函数就会创建一个栈帧
		- 栈顶的栈帧对应着当前正在执行的函数
		- 栈帧是隔离的

			- 因此不同函数可以定义相同的变量而不发生混乱

	- 组成

		- 函数调用传递的参数
		- 局部变量
		- 申请的内存空间的地址变量

- 操作系统管理进程的数据结构

## 计算机如何同时处理多任务

### CPU分时共享技术

- CPU时间分片

	- CPU能力非常强大，看起来每个进程都在同时执行

		- 看起来像是每个进程都独占一个CPU

- 操作系统进行任务调度

	- 同一时刻，正在运行的进程数<=CPU核心数

- 进程并不是总占用CPU

	- CPU分片
	- IO阻塞

### 进程的状态

- 运行

	- 进程正在CPU上执行

- 就绪

	- 进程获取了除CPU外的一切所需资源，正在等待获取CPU的状态

- 阻塞

	- 进程正在等待某事的发生

		- 等待IO完成
		- 等待锁

### 进程间切换

- 进程切换代价非常大

	- 多线程

		- 协程

### 多线程

- 线程

	- 线程轻量级的进程
	- 独享

		- 栈
		- 寄存器等

	- 共享

		- 虚拟系统
		- 全局资源
		- 打开的文件资源

## 系统为什么会变慢、崩溃

### 目前服务器应用实现

- 使用多线程技术实现多任务处理

	- 操作系统启动开发的应用程序(进程)
	- 进程创建多个线程
	- 每个线程处理一个用户请求
	- 举例-Java Web服务开发

		- Tomcat启动多个线程，为每个用户请求分配一个线程

			- 线程池

		- 线程完成每个用户的请求处理
		- JVM被操作系统当做一个独立进程管理
		- 操作系统对资源进行分时(CPU)、分片管理(内存)

### 多线程安全问题

- 多线程访问各自的局部变量没有问题

	- 各个线程的栈相互隔离

- 访问、修改共享资源时，存在线程安全问题

	- 临界区

		- 多线程访问共享资源的这段代码

- 解决线程安全问题的方法

	- 锁

		- 如何保证锁的获取线程安全

			- 原子操作CAS

				- 保证不被其他指令中断、重排

			- PV原语

- 锁会引起线程阻塞

### 系统变慢

- 高并发

	- 竞争资源

		- 锁

			- 相互阻塞

				- 线程无法并发执行、系统响应变慢

- IO阻塞
- 排队等待获取数据库连接

	- 数据库连接资源有限

### 系统崩溃

- 高并发

	- 阻塞线程变多

		- 占用系统的资源变多

			- 阻塞的线程不能得到继续执行，线程占用的资源也不会释放
			- 系统资源耗尽

				- 系统宕机、应用崩溃

### 解决因高并发导致的系统响应变慢甚至崩溃的方法

- 分布式系统架构
- 解决高并发问题

	- 扩容
	- 限流

		- 在请求入口处限流，减小系统的并发请求

	- 降级

